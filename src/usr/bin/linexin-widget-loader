#!/usr/bin/env python3
"""
Widget Loader Application

A GTK4/Libadwaita application that dynamically loads and displays widgets
from a specified directory. Features a sidebar navigation with system-integrated
window controls that respect GNOME settings.
"""

import gi
import os
import sys
import importlib.util
import traceback

gi.require_version('Gtk', '4.0')
gi.require_version('Adw', '1')
gi.require_version('GdkPixbuf', '2.0')

from gi.repository import Gtk, Adw, GLib, GdkPixbuf, Gio


# Constants
WIDGET_DIRECTORY = "/usr/share/linexin/widgets"
SIDEBAR_WIDTH = 330
ICON_SIZE = 32
APP_ID = "github.petexy.LinexinWidgetLoader"


class WidgetLoaderWindow(Adw.ApplicationWindow):
    """Main application window with sidebar and content area."""
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        
        # Window configuration
        self.set_title("Widget Loader")
        self.set_default_size(1280, 720)
        
        # Data storage
        self.loaded_widgets = {}      # widget_name -> widget_instance
        self.widget_metadata = {}      # widget_name -> metadata (icon_path, etc.)
        
        # Initialize settings monitor for window buttons
        self._setup_button_layout_monitoring()
        
        # Build the user interface
        self._build_ui()
        
        # Load all available widgets
        self._load_all_widgets()
    
    # ============================================================
    # INITIALIZATION METHODS
    # ============================================================
    
    def _setup_button_layout_monitoring(self):
        """Monitor GNOME settings for window button layout changes."""
        self.gnome_settings = Gio.Settings.new("org.gnome.desktop.wm.preferences")
        self.current_button_layout = self.gnome_settings.get_string("button-layout")
        
        # Watch for changes in button layout (e.g., from GNOME Tweaks)
        self.gnome_settings.connect(
            "changed::button-layout", 
            self._on_button_layout_changed
        )
    
    def _build_ui(self):
        """Build the main user interface structure."""
        # Create persistent components that won't be recreated
        self._create_persistent_widgets()
        
        # Build the layout structure
        self._build_sidebar()
        self._build_content_area()
        
        # Create the split view container
        self.split_view = Adw.NavigationSplitView()
        self.split_view.set_sidebar(self.sidebar_page)
        self.split_view.set_content(self.content_page)
        
        # Set as window content
        self.set_content(self.split_view)
        
        # Apply visual styling
        self._apply_styling()
    
    def _create_persistent_widgets(self):
        """Create widgets that persist across UI rebuilds."""
        # Main content display area
        self.content_display = Adw.Bin()
        self.content_display.set_hexpand(True)
        self.content_display.set_vexpand(True)
        self._show_placeholder_message()
        
        # Widget list in sidebar
        self.widget_list = Gtk.ListBox()
        self.widget_list.set_selection_mode(Gtk.SelectionMode.SINGLE)
        self.widget_list.add_css_class("navigation-sidebar")
        self.widget_list.connect("row-activated", self._on_widget_selected)
    
    # ============================================================
    # UI BUILDING METHODS
    # ============================================================
    
    def _build_sidebar(self):
        """Build the sidebar with widget list and optional window controls."""
        # Create the navigation page
        self.sidebar_page = Adw.NavigationPage()
        self.sidebar_page.set_title("Widgets")
        
        # Main container with fixed width
        sidebar_container = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        sidebar_container.set_spacing(0)
        sidebar_container.set_size_request(SIDEBAR_WIDTH, -1)
        sidebar_container.set_hexpand(False)  # Keep width fixed
        
        # Add header with window controls (if buttons are on left)
        header = self._create_sidebar_header()
        sidebar_container.append(header)
        
        # Add invisible separator for consistent spacing
        separator = self._create_invisible_separator()
        sidebar_container.append(separator)
        
        # Add scrollable widget list
        scrollable_area = self._create_scrollable_widget_list()
        sidebar_container.append(scrollable_area)
        
        self.sidebar_page.set_child(sidebar_container)
    
    def _create_sidebar_header(self):
        """Create sidebar header with title and optional window controls."""
        header = Gtk.HeaderBar()
        header.add_css_class("flat")
        
        # Add title
        title = Gtk.Label(label="Available Widgets")
        title.add_css_class("heading")
        header.set_title_widget(title)
        
        # Add window controls if they're on the left side
        left_buttons, right_buttons = self._parse_button_layout()
        
        if left_buttons:
            header.set_show_title_buttons(True)
            header.set_decoration_layout(f"{left_buttons}:")
        else:
            header.set_show_title_buttons(False)
        
        return header
    
    def _create_scrollable_widget_list(self):
        """Create scrollable container for the widget list."""
        scrolled_window = Gtk.ScrolledWindow()
        scrolled_window.set_policy(
            Gtk.PolicyType.NEVER,     # No horizontal scrollbar
            Gtk.PolicyType.AUTOMATIC   # Vertical scrollbar when needed
        )
        scrolled_window.set_hexpand(False)
        scrolled_window.set_vexpand(True)
        scrolled_window.set_child(self.widget_list)
        
        # Add margins for better appearance
        container = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        container.set_margin_top(6)
        container.set_margin_bottom(6)
        container.set_margin_start(6)
        container.set_margin_end(6)
        container.append(scrolled_window)
        
        return container
    
    def _build_content_area(self):
        """Build the content area with draggable header and widget display."""
        # Create the navigation page
        self.content_page = Adw.NavigationPage()
        self.content_page.set_title("Widget Content")
        
        # Main container
        content_container = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        content_container.set_spacing(0)
        
        # Always add header for window dragging
        header = self._create_content_header()
        content_container.append(header)
        
        # Add invisible separator
        separator = self._create_invisible_separator()
        content_container.append(separator)
        
        # Add the widget display area
        content_container.append(self.content_display)
        
        self.content_page.set_child(content_container)
    
    def _create_content_header(self):
        """Create content area header (always present for dragging)."""
        header = Gtk.HeaderBar()
        header.add_css_class("flat")
        
        # Check if window controls should be shown here
        left_buttons, right_buttons = self._parse_button_layout()
        
        if right_buttons:
            header.set_show_title_buttons(True)
            header.set_decoration_layout(f":{right_buttons}")
        else:
            # Header present for dragging but no buttons
            header.set_show_title_buttons(False)
        
        # Empty title to keep header clean
        header.set_title_widget(Gtk.Label(label=""))
        
        return header
    
    def _create_invisible_separator(self):
        """Create a separator with opacity 0."""
        separator = Gtk.Separator(orientation=Gtk.Orientation.HORIZONTAL)
        separator.add_css_class("hidden-separator")
        return separator
    
    # ============================================================
    # WIDGET LOADING METHODS
    # ============================================================
    
    def _load_all_widgets(self):
        """Load all widgets from the configured directory."""
        if not os.path.exists(WIDGET_DIRECTORY):
            self._show_error_in_list(
                "No widgets found",
                f"Directory {WIDGET_DIRECTORY} does not exist"
            )
            return
        
        # Find and sort Python files alphabetically
        python_files = [f for f in os.listdir(WIDGET_DIRECTORY) if f.endswith(".py")]
        python_files.sort()  # Explicit alphabetical sorting
        
        for filename in python_files:
            filepath = os.path.join(WIDGET_DIRECTORY, filename)
            module_name = filename[:-3]  # Remove .py extension
            self._load_widget_from_file(filepath, module_name)
    
    def _load_widget_from_file(self, filepath, module_name):
        """Load a widget from a Python file."""
        try:
            # Dynamically import the module
            spec = importlib.util.spec_from_file_location(module_name, filepath)
            if not spec or not spec.loader:
                return
            
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)
            
            # Find widget classes in the module
            self._extract_widgets_from_module(module)
            
        except Exception as e:
            print(f"Error loading widget from {filepath}: {e}")
            traceback.print_exc()
    
    def _extract_widgets_from_module(self, module):
        """Extract widget classes from a loaded module."""
        for attribute_name in dir(module):
            attribute = getattr(module, attribute_name)
            
            # Check if it's a class
            if not isinstance(attribute, type):
                continue
            
            try:
                # Try to instantiate the widget
                widget_instance = attribute()
                
                # Check if it has the required widgetname attribute
                if hasattr(widget_instance, 'widgetname'):
                    self._register_widget(widget_instance)
                    
            except Exception:
                # Skip classes that can't be instantiated
                continue
    
    def _register_widget(self, widget_instance):
        """Register a widget and add it to the sidebar."""
        widget_name = widget_instance.widgetname
        
        # Store the widget instance
        self.loaded_widgets[widget_name] = widget_instance
        
        # Store metadata
        icon_path = getattr(widget_instance, 'widgeticon', None)
        self.widget_metadata[widget_name] = {
            'icon_path': icon_path
        }
        
        # Add to sidebar
        self._add_widget_to_sidebar(widget_name, icon_path)
    
    def _add_widget_to_sidebar(self, widget_name, icon_path=None):
        """Add a widget entry to the sidebar list."""
        row = Adw.ActionRow()
        row.set_title(widget_name)
        row.set_activatable(True)
        row.widget_name = widget_name  # Store reference for selection
        
        # Add icon
        icon = self._load_widget_icon(icon_path)
        row.add_prefix(icon)
        
        self.widget_list.append(row)
    
    def _load_widget_icon(self, icon_path):
        """Load an icon from a file path or return default icon."""
        # Use default icon if no path provided
        if not icon_path or not os.path.exists(icon_path):
            image = Gtk.Image.new_from_icon_name("application-x-addon-symbolic")
            image.set_pixel_size(ICON_SIZE)
            return image
        
        try:
            file_extension = os.path.splitext(icon_path)[1].lower()
            
            if file_extension == '.svg':
                # SVG files can be loaded directly
                image = Gtk.Image()
                image.set_from_file(icon_path)
                image.set_pixel_size(ICON_SIZE)
                return image
            else:
                # Other formats (PNG, JPEG, etc.) need GdkPixbuf
                pixbuf = GdkPixbuf.Pixbuf.new_from_file_at_size(
                    icon_path, ICON_SIZE, ICON_SIZE
                )
                image = Gtk.Image.new_from_pixbuf(pixbuf)
                # Important: Set pixel size for consistency
                image.set_pixel_size(ICON_SIZE)
                return image
                
        except Exception as e:
            print(f"Error loading icon from {icon_path}: {e}")
            image = Gtk.Image.new_from_icon_name("application-x-addon-symbolic")
            image.set_pixel_size(ICON_SIZE)
            return image
    
    # ============================================================
    # EVENT HANDLERS
    # ============================================================
    
    def _on_widget_selected(self, listbox, row):
        """Handle widget selection from the sidebar."""
        if not hasattr(row, 'widget_name'):
            return
        
        widget_name = row.widget_name
        if widget_name not in self.loaded_widgets:
            return
        
        # Clear current content
        self.content_display.set_child(None)
        
        # Get and display the widget
        widget_instance = self.loaded_widgets[widget_name]
        self._display_widget(widget_instance, widget_name)
        
        # Update page title
        self.content_page.set_title(widget_name)
    
    def _display_widget(self, widget_instance, widget_name):
        """Display a widget in the content area."""
        if isinstance(widget_instance, Gtk.Widget):
            # Direct GTK widget
            self.content_display.set_child(widget_instance)
            
        elif hasattr(widget_instance, 'get_widget'):
            # Widget provides a method to get the GTK widget
            try:
                gtk_widget = widget_instance.get_widget()
                self.content_display.set_child(gtk_widget)
            except Exception as e:
                self._show_widget_error(widget_name, str(e))
        else:
            # Widget cannot be displayed
            self._show_widget_error(widget_name, "Widget cannot be displayed")
    
    def _on_button_layout_changed(self, settings, key):
        """Handle changes to window button layout from GNOME settings."""
        self.current_button_layout = settings.get_string("button-layout")
        self._rebuild_headers()
    
    def _rebuild_headers(self):
        """Rebuild headers when button layout changes."""
        # Save current state
        selected_row = self.widget_list.get_selected_row()
        selected_widget = (
            selected_row.widget_name 
            if selected_row and hasattr(selected_row, 'widget_name') 
            else None
        )
        current_content = self.content_display.get_child()
        
        # Detach persistent widgets from their parents
        if self.widget_list.get_parent():
            self.widget_list.get_parent().set_child(None)
        if self.content_display.get_parent():
            self.content_display.get_parent().remove(self.content_display)
        
        # Rebuild the UI structure
        self._build_sidebar()
        self._build_content_area()
        
        # Update split view
        self.split_view.set_sidebar(self.sidebar_page)
        self.split_view.set_content(self.content_page)
        
        # Restore state
        if current_content:
            self.content_display.set_child(current_content)
        if selected_widget:
            self._restore_selection(selected_widget)
    
    def _restore_selection(self, widget_name):
        """Restore widget selection after UI rebuild."""
        for row in self.widget_list:
            if hasattr(row, 'widget_name') and row.widget_name == widget_name:
                self.widget_list.select_row(row)
                break
    
    # ============================================================
    # UTILITY METHODS
    # ============================================================
    
    def _parse_button_layout(self):
        """Parse the button layout string to determine left/right buttons."""
        if ":" in self.current_button_layout:
            left, right = self.current_button_layout.split(":")
            return left, right
        else:
            # All buttons on one side (assume left)
            return self.current_button_layout, ""
    
    def _show_placeholder_message(self):
        """Show placeholder message in content area."""
        placeholder = Gtk.Label(label="Select a widget from the sidebar")
        placeholder.set_vexpand(True)
        placeholder.set_hexpand(True)
        self.content_display.set_child(placeholder)
    
    def _show_widget_error(self, widget_name, error_message):
        """Show error message when widget cannot be displayed."""
        error_label = Gtk.Label(
            label=f"Error loading '{widget_name}': {error_message}"
        )
        error_label.set_vexpand(True)
        error_label.set_hexpand(True)
        error_label.add_css_class("dim-label")
        self.content_display.set_child(error_label)
    
    def _show_error_in_list(self, title, subtitle):
        """Show error message in the widget list."""
        row = Adw.ActionRow()
        row.set_title(title)
        row.set_subtitle(subtitle)
        self.widget_list.append(row)
    
    def _apply_styling(self):
        """Apply custom CSS styling to the application."""
        css = """
            /* Flat header bars with transparent background */
            headerbar.flat {
                min-height: 0;
                padding-top: 3px;
                padding-bottom: 3px;
                background: transparent;
                border: none;
                box-shadow: none;
            }
            
            /* Invisible separators */
            .hidden-separator {
                opacity: 0;
                min-height: 1px;
            }
            
            /* Dim label for errors */
            .dim-label {
                opacity: 0.6;
            }

            .buttons_all {
                font-size: 14px;
                min-width: 200px;
                min-height: 40px;
        }
        """
        
        css_provider = Gtk.CssProvider()
        css_provider.load_from_data(css.encode())
        
        Gtk.StyleContext.add_provider_for_display(
            self.get_display(),
            css_provider,
            Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION
        )


class WidgetLoaderApp(Adw.Application):
    """Main application class."""
    
    def __init__(self, **kwargs):
        super().__init__(application_id=APP_ID, **kwargs)
        self.connect('activate', self.on_activate)
    
    def on_activate(self, app):
        """Handle application activation."""
        self.window = WidgetLoaderWindow(application=app)
        self.window.present()


def main():
    """Application entry point."""
    app = WidgetLoaderApp()
    return app.run(sys.argv)


if __name__ == '__main__':
    main()


"""
Example widget file to be placed in /usr/share/linexin/widgets/:
========================================================================

import gi
gi.require_version('Gtk', '4.0')
from gi.repository import Gtk

class MyCustomWidget(Gtk.Box):
    def __init__(self):
        super().__init__(orientation=Gtk.Orientation.VERTICAL, spacing=12)
        
        # Required: Widget display name
        self.widgetname = "My Custom Widget"
        
        # Optional: Widget icon (supports .svg, .png, .jpg, etc.)
        self.widgeticon = "/usr/share/linexin/widgets/icons/my_widget.svg"
        
        # Widget content
        self.set_margin_top(12)
        self.set_margin_bottom(12)
        self.set_margin_start(12)
        self.set_margin_end(12)
        
        title = Gtk.Label(label="Welcome to My Custom Widget!")
        title.add_css_class("title-2")
        self.append(title)
        
        description = Gtk.Label(label="This is an example widget with a custom icon")
        self.append(description)
        
        button = Gtk.Button(label="Click Me!")
        button.set_halign(Gtk.Align.CENTER)
        self.append(button)
"""